<?xml version="1.0" encoding="utf-8" ?>
<DynLINQDoc xmlns="http://schemas.plainlogic.net/dynamiclinqdocs/2014">
  
  <Classes>
    <Class name="BasicQueryable" namespace="System.Linq.Dynamic">
      <Description>Provides a set of **static** methods for querying data structures that implement `IQueryable`.</Description>
      <Remarks>The purpose of this class is to mimic several basic methods implemented by the standard `System.Linq.IQueryable&lt;T&gt;`, but that work with `IQueryable`.</Remarks>
      
      <Methods>
        
        <Method name="Take" isExtensionMethod="true" returnType="IQueryable">
          <Description>Returns a specified number of contiguous elements from the start of a sequence.</Description>
          <Remarks>`Take` enumerates *source* and *yields* elements until *count* elements have been yielded or *source* contains no more elements.&#xA;&#xA;If *count* is less than or equal to zero, *source* is not enumerated and an empty `IQueryable` is returned.</Remarks>
          <ReturnDescription>A `IQueryable` that contains the specified number of elements from the start of `source`.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>The sequence to return elements from.</Description>
            </Argument>
            <Argument name="count" type="int" typeNamespace="System.Int32">
              <Description>The number of elements to return.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Take(IQueryable, Int32)` to return elements from the start of a sequence.</HeaderRemarks>
              <ExampleCode>int[] grades = { 59, 82, 70, 56, 92, 98, 85 };
              
// Sort the grades in descending order and take the first three.
IEnumerable&lt;int&gt; topThreeGrades =
    grades.AsQueryable().OrderByDescending(grade => grade).Take(3);
    
Console.WriteLine("The top three grades are:");
foreach (int grade in topThreeGrades)
    Console.WriteLine(grade);
  
/*
    This code produces the following output:

    The top three grades are:
    98
    92
    85
*/</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="Skip" isExtensionMethod="true" returnType="IQueryable">
          <Description>Bypasses a specified number of elements in a sequence and then returns the remaining elements.</Description>
          <ReturnDescription>A `IQueryable` that contains elements that occur after the specified index in the input sequence.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>The sequence to return elements from.</Description>
            </Argument>
            <Argument name="count" type="int" typeNamespace="System.Int32">
              <Description>The number of elements to skip before returning the remaining elements.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Skip(IQueryable, Int32)` to skip a specified number of elements in a sorted array and return the remaining elements.</HeaderRemarks>
              <ExampleCode>int[] grades = { 59, 82, 70, 56, 92, 98, 85 };

// Sort the grades in descending order get all except the first three.
IEnumerable&lt;int&gt; lowerGrades =
    grades.AsQueryable().OrderByDescending(grade => grade).Skip(3);

Console.WriteLine("All grades except the top three are:");
foreach (int grade in topThreeGrades)
    Console.WriteLine(grade);

/*
    This code produces the following output:

    All grades except the top three are:
    82
    70
    59
    56
*/</ExampleCode>
            </Example>
          </Examples>
        </Method>
        
        <Method name="Reverse" isExtensionMethod="true" returnType="IQueryable">
          <Description>Inverts the order of the elements in a sequence.</Description>
          <ReturnDescription>A `IQueryable` whose elements correspond to those of the input sequence in reverse order.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A sequence of values to reverse.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Reverse(IQueryable)` to reverse the order of elements in an array.</HeaderRemarks>
              <ExampleCode>char[] apple = { 'a', 'p', 'p', 'l', 'e' };

// Reverse the order of the characters in the collection.
IQueryable query = apple.AsQueryable();
IQueryable reversed = query.Reverse();

foreach (char chr in reversed)
    Console.Write(chr + " ");
Console.WriteLine();

/*
    This code produces the following output:

    e l p p a
*/</ExampleCode>
            </Example>
          </Examples>
        </Method>
    
        <Method name="Any" isExtensionMethod="true" returnType="bool">
          <Description>Determines whether a sequence contains any elements.</Description>
          <ReturnDescription>`true` if the source sequence contains any elements; otherwise, `false`.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A sequence to check for being empty.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Any(IQueryable)` to determine whether a sequence contains any elements.</HeaderRemarks>
              <ExampleCode>List&lt;int&gt;
numbers = new List&lt;int&gt; { 1, 2 };

// Determine if the list contains any elements.
bool hasElements = numbers.AsQueryable().Any();

Console.WriteLine("The list {0} empty.",
    hasElements ? "is not" : "is");

// This code produces the following output:
//
// The list is not empty.</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="Count" isExtensionMethod="true" returnType="int">
          <Description>Returns the number of elements in a sequence.</Description>
          <ReturnDescription>The number of elements in the input sequence.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>The `IQueryable` that contains the elements to be counted.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Count(IQueryable)` to count the elements in a sequence.</HeaderRemarks>
              <ExampleCode>string[] fruits = { "apple", "banana", "mango",
"orange", "passionfruit", "grape" };

int numberOfFruits = fruits.AsQueryable().Count();

Console.WriteLine(
    "There are {0} items in the array.",
    numberOfFruits);

// This code produces the following output:
//
// There are 6 items in the array.</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="Single" frameworks="Net35" isExtensionMethod="true" returnType="object">
          <Description>Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence.</Description>
          <ReturnDescription>The single element of the input sequence.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the single element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="Single" frameworks="Net40Plus" isExtensionMethod="true" returnType="dynamic">
          <Description>Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence.</Description>
          <ReturnDescription>The single element of the input sequence.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the single element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="SingleOrDefault" frameworks="Net35" isExtensionMethod="true" returnType="object">
          <Description>Returns the only element of a sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.</Description>
          <ReturnDescription>The single element of the input sequence, or `null` if the sequence contains no elements.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the single element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="SingleOrDefault" frameworks="Net40Plus" isExtensionMethod="true" returnType="dynamic">
          <Description>Returns the only element of a sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.</Description>
          <ReturnDescription>The single element of the input sequence, or `null` if the sequence contains no elements.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the single element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="First" frameworks="Net35" isExtensionMethod="true" returnType="object">
          <Description>Returns the first element of a sequence.</Description>
          <ReturnDescription>The first element in source.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the first element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="First" frameworks="Net40Plus" isExtensionMethod="true" returnType="dynamic">
          <Description>Returns the first element of a sequence.</Description>
          <ReturnDescription>The first element in source.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the first element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="FirstOrDefault" frameworks="Net35" isExtensionMethod="true" returnType="object">
          <Description>Returns the first element of a sequence, or a default value if the sequence contains no elements.</Description>
          <ReturnDescription>`null` if source is empty; otherwise, the first element in *source*.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the first element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="FirstOrDefault" frameworks="Net40Plus" isExtensionMethod="true" returnType="dynamic">
          <Description>Returns the first element of a sequence, or a default value if the sequence contains no elements.</Description>
          <ReturnDescription>`null` if source is empty; otherwise, the first element in *source*.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to return the first element of.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="AsEnumerable" frameworks="Net35" isExtensionMethod="true" returnType="IEnumerable&lt;object&gt;">
          <Description>Returns the input typed as `IEnumerable&lt;T&gt;` of `object`.</Description>
          <ReturnDescription>The input typed as `IEnumerable&lt;T&gt;` of `object`.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>The sequence to type as `IEnumerable&lt;T&gt;` of `object`.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="AsEnumerable" frameworks="Net40Plus" isExtensionMethod="true" returnType="IEnumerable&lt;dynamic&gt;">
          <Description>Returns the input typed as `IEnumerable&lt;T&gt;` of `dynamic`.</Description>
          <ReturnDescription>The input typed as `IEnumerable&lt;T&gt;` of `dynamic`.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>The sequence to type as `IEnumerable&lt;T&gt;` of `dynamic`.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="ToDynamicArray" frameworks="Net40Plus" isExtensionMethod="true" returnType="dynamic[]">
          <Description>Creates an array of `dynamic` `objects` from a `IEnumerable`.</Description>
          <ReturnDescription>An array that contains the elements from the input sequence.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to create an array from.</Description>
            </Argument>
          </Arguments>
        </Method>
        
      </Methods>
    </Class>  <!--BasicQueryable-->

    <Class name="DynamicQueryable" namespace="System.Linq.Dynamic">
      <Description>Provides a set of **static** methods for querying data structures that implement `IQueryable`. It allows dynamic string based querying.  Very handy when, at compile time, you don't know the type of queries that will be generated, or when downstream components only return column names to sort and filter by.</Description>
      <Remarks></Remarks>

      <Methods>
        <Method name="Where&lt;TSource&gt;" isExtensionMethod="true" returnType="IQueryable&lt;TSource&gt;" hasParamsArgument="true">
          <Description>Filters a sequence of values based on a predicate.</Description>
          <ReturnDescription>A `IQueryable&lt;TSource&gt;` that contains elements from the input sequence that satisfy the condition specified by predicate.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable&lt;TSource&gt;" typeNamespace="System.Linq">
              <Description>A `IQueryable` to filter.</Description>
            </Argument>
            <Argument name="predicate" type="string" typeNamespace="System">
              <Description>An expression string to test each element for a condition.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a *basic value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>List&lt;string&gt; fruits =
    new List&lt;string> { "apple", "passionfruit", "banana", "mango", 
                        "orange", "blueberry", "grape", "strawberry" };

// Get all strings whose length is less than 6.
IEnumerable query = fruits.AsQueryable().Where("fruit.Length &lt; 6");

foreach (string fruit in query)
    Console.WriteLine(fruit);

/*
    This code produces the following output:

    apple
    mango
    grape
*/</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a *static argument value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>IEnumerable&lt;string&gt; query = fruits.AsQueryable().Where("fruit.Length &lt; @0", 1);</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a *variable argument value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>int someValue = 6;
 
IEnumerable&lt;string&gt; query = fruits.AsQueryable().Where("fruit.Length &lt; @0", someValue);</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="Where" isExtensionMethod="true" returnType="IQueryable" hasParamsArgument="true">
          <Description>Filters a sequence of values based on a predicate.</Description>
          <ReturnDescription>A `IQueryable` that contains elements from the input sequence that satisfy the condition specified by predicate.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` to filter.</Description>
            </Argument>
            <Argument name="predicate" type="string" typeNamespace="System">
              <Description>An expression string to test each element for a condition.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a *basic value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>List&lt;string&gt; fruits =
    new List&lt;string> { "apple", "passionfruit", "banana", "mango", 
                        "orange", "blueberry", "grape", "strawberry" };

// Get all strings whose length is less than 6.
IEnumerable query = fruits.AsQueryable().Where("fruit.Length &lt; 6");

foreach (string fruit in query)
    Console.WriteLine(fruit);

/*
    This code produces the following output:

    apple
    mango
    grape
*/</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a *static argument value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>IEnumerable&lt;string&gt; query = fruits.AsQueryable().Where("fruit.Length &lt; @0", 1);</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a *variable argument value* used in the `Where` string expression to filter a sequence.</HeaderRemarks>
              <ExampleCode>int someValue = 6;
 
IEnumerable&lt;string&gt; query = fruits.AsQueryable().Where("fruit.Length &lt; @0", someValue);</ExampleCode>
            </Example>
          </Examples>
        </Method>
        
        <Method name="Select" isExtensionMethod="true" hasParamsArgument="true" returnType="IQueryable">
          <Description>Projects each element of a sequence into a new form.</Description>
          <ReturnDescription>An `IQueryable` whose elements are the result of invoking a projection string on each element of *source*.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A sequence of values to project.</Description>
            </Argument>
            <Argument name="selector" type="string" typeNamespace="System">
              <Description>A projection string expression to apply to each element.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Select` to project over a sequence of values, using the `it` keyword.</HeaderRemarks>
              <ExampleCode>List&lt;int&gt; range =
    new List&lt;int&gt; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Project the square of each int value.
IEnumerable squares =
    range.AsQueryable().Select("it * it");

foreach (int num in squares)
    Console.WriteLine(num);

/*
    This code produces the following output:

    1
    4
    9
    16
    25
    36
    49
    64
    81
    100
*/</ExampleCode>
              <EquivalentCode>List&lt;int&gt; range =
    new List&lt;int&gt; { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

// Project the square of each int value.
IEnumerable&lt;int&gt; squares =
    range.AsQueryable().Select(x => x * x);

foreach (int num in squares)
    Console.WriteLine(num);

/*
    This code produces the following output:

    1
    4
    9
    16
    25
    36
    49
    64
    81
    100
*/</EquivalentCode>
            </Example>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Select` to project a single field and a group of fields over a sequence of values.</HeaderRemarks>
              <ExampleCode>class ExampleClass
{
    public string StringProperty1 { get; set; }
    public string StringProperty2 { get; set; }
}

//Select a single field
var singleField = qry.Select("StringProperty");
    
//Select a group of fields
var dynamicObject = qry.Select("new (StringProperty1, StringProperty2 as OtherStringPropertyName)");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="SelectMany" isExtensionMethod="true" hasParamsArgument="true" returnType="IQueryable">
          <Description>Projects each element of a sequence to an `IQueryable` and combines the resulting sequences into one sequence.</Description>
          <ReturnDescription>An `IQueryable` whose elements are the result of invoking a one-to-many projection function on each element of the input sequence.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A sequence of values to project.</Description>
            </Argument>
            <Argument name="selector" type="string" typeNamespace="System">
              <Description>A projection string expression to apply to each element.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `SelectMany` to perform a one-to-many projection over an array.</HeaderRemarks>
              <ExampleCode>class PetOwner
{
    public string Name { get; set; }
    public List&lt;String&gt; Pets { get; set; }
}

public static void SelectManyEx1()
{
    PetOwner[] petOwners =
        { new PetOwner { Name="Higa, Sidney",
              Pets = new List&lt;string&gt;{ "Scruffy", "Sam" } },
          new PetOwner { Name="Ashkenazi, Ronen",
              Pets = new List&lt;string&gt;{ "Walker", "Sugar" } },
          new PetOwner { Name="Price, Vernette",
              Pets = new List&lt;string&gt;{ "Scratches", "Diesel" } } };

    // Query using SelectMany().
    IEnumerable query1 =
        petOwners.AsQueryable().SelectMany("Pets");

    Console.WriteLine("Using SelectMany():");

    // Only one foreach loop is required to iterate through the
    // results because it is a one-dimensional collection.
    foreach (string pet in query1)
        Console.WriteLine(pet);

    // This code shows how to use Select() instead of SelectMany().
    IEnumerable query2 =
        petOwners.AsQueryable().Select("Pets");

    Console.WriteLine("\nUsing Select():");

    // Notice that two foreach loops are required to iterate through
    // the results because the query returns a collection of arrays.
    foreach (IEnumerable petList in query2)
    {
        foreach (string pet in petList)
        {
            Console.WriteLine(pet);
        }
        Console.WriteLine();
    }
}

/*
    This code produces the following output:

    Using SelectMany():
    Scruffy
    Sam
    Walker
    Sugar
    Scratches
    Diesel

    Using Select():
    Scruffy
    Sam

    Walker
    Sugar

    Scratches
    Diesel
*/</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="OrderBy&lt;TSource&gt;" isExtensionMethod="true" hasParamsArgument="true" returnType="IQueryable&lt;TSource&gt;">
          <Description>Sorts the elements of a sequence in ascending order according to a key.</Description>
          <ReturnDescription>A `IQueryable&lt;T&gt;` whose elements are sorted according to the specified **ordering**.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable&lt;TSource&gt;" typeNamespace="System.Linq">
              <Description>A sequence of values to order.</Description>
            </Argument>
            <Argument name="ordering" type="string" typeNamespace="System">
              <Description>An expression string to indicate values to order by.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <ExampleCode>var result = list.OrderBy("NumberProperty, StringProperty DESC");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="OrderBy" isExtensionMethod="true" hasParamsArgument="true" returnType="IQueryable">
          <Description>Sorts the elements of a sequence in ascending order according to a key.</Description>
          <ReturnDescription>A `IQueryable` whose elements are sorted according to the specified **ordering**.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A sequence of values to order.</Description>
            </Argument>
            <Argument name="ordering" type="string" typeNamespace="System">
              <Description>An expression string to indicate values to order by.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way `String.Format` formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <ExampleCode>var result = list.OrderBy("NumberProperty, StringProperty DESC");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="GroupBy" isExtensionMethod="true" returnType="IQueryable">
          <Description>Groups the elements of a sequence according to a specified key string function and creates a result value from each group and its key.</Description>
          <ReturnDescription>A `IQueryable` where each element represents a projection over a group and its key.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelector" type="string" typeNamespace="System">
              <Description>A string expression to specify the key for each element.</Description>
            </Argument>
            <Argument name="resultSelector" type="string" typeNamespace="System">
              <Description>A string expression to specify a result value from each group.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way String.Format formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a simple `GroupBy`.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("NumberPropertyAsKey", "StringProperty");</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a `GroupBy` using multiple key fields and multiple grouped fields.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("new (NumberPropertyAsKey, StringPropertyAsKey)", "new (StringProperty1, StringProperty2)");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="GroupBy" isExtensionMethod="true" returnType="IQueryable">
          <Description>Groups the elements of a sequence according to a specified key string function and creates a result value from each group and its key.</Description>
          <ReturnDescription>A `IQueryable` where each element represents a projection over a group and its key.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelector" type="string" typeNamespace="System">
              <Description>A string expression to specify the key for each element.</Description>
            </Argument>
            <Argument name="resultSelector" type="string" typeNamespace="System">
              <Description>A string expression to specify a result value from each group.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a simple `GroupBy`.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("NumberPropertyAsKey", "StringProperty");</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a `GroupBy` using multiple key fields and multiple grouped fields.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("new (NumberPropertyAsKey, StringPropertyAsKey)", "new (StringProperty1, StringProperty2)");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="GroupBy" isExtensionMethod="true" returnType="IQueryable">
          <Description>Groups the elements of a sequence according to a specified key string function and creates a result value from each group and its key.</Description>
          <ReturnDescription>A `IQueryable` where each element represents a projection over a group and its key.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelector" type="string" typeNamespace="System">
              <Description>A string expression to specify the key for each element.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicate as parameters.  Similiar to the way String.Format formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a simple `GroupBy`.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("NumberPropertyAsKey", "StringProperty");</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a `GroupBy` using multiple key fields and multiple grouped fields.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("new (NumberPropertyAsKey, StringPropertyAsKey)", "new (StringProperty1, StringProperty2)");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="GroupBy" isExtensionMethod="true" returnType="IQueryable">
          <Description>Groups the elements of a sequence according to a specified key string function and creates a result value from each group and its key.</Description>
          <ReturnDescription>A `IQueryable` where each element represents a projection over a group and its key.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IQueryable" typeNamespace="System.Linq">
              <Description>A `IQueryable` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelector" type="string" typeNamespace="System">
              <Description>A string expression to specify the key for each element.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following is an example of a simple `GroupBy`.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("NumberPropertyAsKey", "StringProperty");</ExampleCode>
            </Example>
            <Example>
              <HeaderRemarks>The following is an example of a `GroupBy` using multiple key fields and multiple grouped fields.</HeaderRemarks>
              <ExampleCode>var groupResult = qry.GroupBy("new (NumberPropertyAsKey, StringPropertyAsKey)", "new (StringProperty1, StringProperty2)");</ExampleCode>
            </Example>
          </Examples>
        </Method>

        <Method name="GroupByMany&lt;TElement&gt;" isExtensionMethod="true" hasParamsArgument="true" returnType="IEnumerable&lt;GroupResult&gt;">
          <Description>Groups the elements of a sequence according to multiple specified key string functions and creates a result value from each group (and subgroups) and its key.</Description>
          <ReturnDescription>A `IEnumerable&lt;GroupResult&gt;` where each element represents a projection over a group, its key, and its subgroups.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IEnumerable&lt;TElement&gt;" typeNamespace="System.Collections.Generic">
              <Description>A `IEnumerable&lt;TElement&gt;` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelectors" type="string[]" typeNamespace="System">
              <Description>`string` expressions to specify the keys for each element.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="GroupByMany&lt;TElement&gt;" isExtensionMethod="true" hasParamsArgument="true" returnType="IEnumerable&lt;GroupResult&gt;">
          <Description>Groups the elements of a sequence according to multiple specified key string functions and creates a result value from each group (and subgroups) and its key.</Description>
          <ReturnDescription>A `IEnumerable&lt;GroupResult&gt;` where each element represents a projection over a group, its key, and its subgroups.</ReturnDescription>
          <Arguments>
            <Argument name="source" type="IEnumerable&lt;TElement&gt;" typeNamespace="System.Collections.Generic">
              <Description>A `IEnumerable&lt;TElement&gt;` whose elements to group.</Description>
            </Argument>
            <Argument name="keySelectors" type="Func&lt;TElement,object&gt;[]" typeNamespace="System">
              <Description>Lambda expressions to specify the keys for each element.</Description>
            </Argument>
          </Arguments>
        </Method>

        <Method name="Join" returnType="IQueryable" isExtensionMethod="true" hasParamsArgument="true">
          <Description>Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.</Description>
          <ReturnDescription>An `IQueryable` obtained by performing an inner join on two sequences.</ReturnDescription>
          <Arguments>
            <Argument name="outer" type="IQueryable" typeNamespace="System.Linq">
              <Description>The first sequence to join.</Description>
            </Argument>
            <Argument name="inner" type="IEnumerable" typeNamespace="System.Collections">
              <Description>The sequence to join to the first sequence.</Description>
            </Argument>
            <Argument name="outerKeySelector" type="string" typeNamespace="System">
              <Description>A dynamic function to extract the join key from each element of the first sequence.</Description>
            </Argument>
            <Argument name="innerKeySelector" type="string" typeNamespace="System">
              <Description>A dynamic function to extract the join key from each element of the second sequence.</Description>
            </Argument>
            <Argument name="resultSelector" type="string" typeNamespace="System">
              <Description>A dynamic function to create a result element from two matching elements.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicates as parameters.  Similiar to the way String.Format formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Join` to perform an inner join of two sequences based on a common key using Dynamic LINQ.</HeaderRemarks>
              <ExampleCode>class Person
{
    public string Name { get; set; }
}

class Pet
{
    public string Name { get; set; }
    public Person Owner { get; set; }
}

public static void JoinEx1()
{
    Person magnus = new Person { Name = "Hedlund, Magnus" };
    Person terry = new Person { Name = "Adams, Terry" };
    Person charlotte = new Person { Name = "Weiss, Charlotte" };

    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };

    List&lt;Person&gt; people = new List&lt;Person&gt; { magnus, terry, charlotte };
    List&lt;Pet&gt; pets = new List&lt;Pet&gt; { barley, boots, whiskers, daisy };

    // Join the list of Person objects and the list of Pet objects 
    // to create a list of person-pet pairs where each element is 
    // an anonymous type that contains the name of pet and the name
    // of the person that owns the pet.
    var query = people.AsQueryable().Join(
        pets,
        "it",
        "Owner",
        "new(outer.Name as OwnerName, inner.Name as Pet)";
      

    foreach (var obj in query)
    {
        Console.WriteLine(
            "{0} - {1}",
            obj.OwnerName,
            obj.Pet);
    }
}

/*
    This code produces the following output:

    Hedlund, Magnus - Daisy
    Adams, Terry - Barley
    Adams, Terry - Boots
    Weiss, Charlotte - Whiskers
*/</ExampleCode>
              <EquivalentCode>class Person
{
    public string Name { get; set; }
}

class Pet
{
    public string Name { get; set; }
    public Person Owner { get; set; }
}

public static void JoinEx1()
{
    Person magnus = new Person { Name = "Hedlund, Magnus" };
    Person terry = new Person { Name = "Adams, Terry" };
    Person charlotte = new Person { Name = "Weiss, Charlotte" };

    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };

    List&lt;Person&gt; people = new List&lt;Person&gt; { magnus, terry, charlotte };
    List&lt;Pet&gt; pets = new List&lt;Pet&gt; { barley, boots, whiskers, daisy };

    // Join the list of Person objects and the list of Pet objects 
    // to create a list of person-pet pairs where each element is 
    // an anonymous type that contains the name of pet and the name
    // of the person that owns the pet.
    var query = people.AsQueryable().Join(
        pets,
        person => person,
        pet => pet.Owner,
        (person, pet) =>
            new { OwnerName = person.Name, Pet = pet.Name });

    foreach (var obj in query)
    {
        Console.WriteLine(
            "{0} - {1}",
            obj.OwnerName,
            obj.Pet);
    }
}

/*
    This code produces the following output:

    Hedlund, Magnus - Daisy
    Adams, Terry - Barley
    Adams, Terry - Boots
    Weiss, Charlotte - Whiskers
*/</EquivalentCode>
            </Example>
          </Examples>
        </Method>
         
        <Method name="Join&lt;TElement&gt;" returnType="IQueryable&lt;TElement&gt;" isExtensionMethod="true" hasParamsArgument="true">
          <Description>Correlates the elements of two sequences based on matching keys. The default equality comparer is used to compare keys.</Description>
          <Remarks>This `Join` overload only works on elements where both sequences and the resulting element match.</Remarks>
          <ReturnDescription>An `IQueryable&lt;TElement&gt;` obtained by performing an inner join on two sequences.</ReturnDescription>
          <Arguments>
            <Argument name="outer" type="IQueryable&lt;TElement&gt;" typeNamespace="System.Linq">
              <Description>The first sequence to join.</Description>
            </Argument>
            <Argument name="inner" type="IEnumerable&lt;TElement&gt;" typeNamespace="System.Collections">
              <Description>The sequence to join to the first sequence.</Description>
            </Argument>
            <Argument name="outerKeySelector" type="string" typeNamespace="System">
              <Description>A dynamic function to extract the join key from each element of the first sequence.</Description>
            </Argument>
            <Argument name="innerKeySelector" type="string" typeNamespace="System">
              <Description>A dynamic function to extract the join key from each element of the second sequence.</Description>
            </Argument>
            <Argument name="resultSelector" type="string" typeNamespace="System">
              <Description>A dynamic function to create a result element from two matching elements.</Description>
            </Argument>
            <Argument name="args" type="object[]" typeNamespace="System">
              <Description>An object array that contains zero or more objects to insert into the predicates as parameters.  Similiar to the way String.Format formats strings.</Description>
            </Argument>
          </Arguments>
          <Examples>
            <Example>
              <HeaderRemarks>The following code example demonstrates how to use `Join` to perform an inner join of two sequences based on a common key using Dynamic LINQ.</HeaderRemarks>
              <ExampleCode>class Person
{
    public string Name { get; set; }
}

class Pet
{
    public string Name { get; set; }
    public Person Owner { get; set; }
}

public static void JoinEx1()
{
    Person magnus = new Person { Name = "Hedlund, Magnus" };
    Person terry = new Person { Name = "Adams, Terry" };
    Person charlotte = new Person { Name = "Weiss, Charlotte" };

    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };

    List&lt;Person&gt; people = new List&lt;Person&gt; { magnus, terry, charlotte };
    List&lt;Pet&gt; pets = new List&lt;Pet&gt; { barley, boots, whiskers, daisy };

    // Join the list of Person objects and the list of Pet objects 
    // to create a list of person-pet pairs where each element is 
    // an anonymous type that contains the name of pet and the name
    // of the person that owns the pet.
    var query = people.AsQueryable().Join(
        pets,
        "it",
        "Owner",
        "new(outer.Name as OwnerName, inner.Name as Pet)";
      

    foreach (var obj in query)
    {
        Console.WriteLine(
            "{0} - {1}",
            obj.OwnerName,
            obj.Pet);
    }
}

/*
    This code produces the following output:

    Hedlund, Magnus - Daisy
    Adams, Terry - Barley
    Adams, Terry - Boots
    Weiss, Charlotte - Whiskers
*/</ExampleCode>
              <EquivalentCode>class Person
{
    public string Name { get; set; }
}

class Pet
{
    public string Name { get; set; }
    public Person Owner { get; set; }
}

public static void JoinEx1()
{
    Person magnus = new Person { Name = "Hedlund, Magnus" };
    Person terry = new Person { Name = "Adams, Terry" };
    Person charlotte = new Person { Name = "Weiss, Charlotte" };

    Pet barley = new Pet { Name = "Barley", Owner = terry };
    Pet boots = new Pet { Name = "Boots", Owner = terry };
    Pet whiskers = new Pet { Name = "Whiskers", Owner = charlotte };
    Pet daisy = new Pet { Name = "Daisy", Owner = magnus };

    List&lt;Person&gt; people = new List&lt;Person&gt; { magnus, terry, charlotte };
    List&lt;Pet&gt; pets = new List&lt;Pet&gt; { barley, boots, whiskers, daisy };

    // Join the list of Person objects and the list of Pet objects 
    // to create a list of person-pet pairs where each element is 
    // an anonymous type that contains the name of pet and the name
    // of the person that owns the pet.
    var query = people.AsQueryable().Join(
        pets,
        person => person,
        pet => pet.Owner,
        (person, pet) =>
            new { OwnerName = person.Name, Pet = pet.Name });

    foreach (var obj in query)
    {
        Console.WriteLine(
            "{0} - {1}",
            obj.OwnerName,
            obj.Pet);
    }
}

/*
    This code produces the following output:

    Hedlund, Magnus - Daisy
    Adams, Terry - Barley
    Adams, Terry - Boots
    Weiss, Charlotte - Whiskers
*/</EquivalentCode>
            </Example>
          </Examples>
        </Method>
      </Methods>
    </Class>

    <Class name="ParseException" namespace="System.Linq.Dynamic">
      <Description>Represents errors that occur while parsing dynamic linq string expressions.</Description>
    </Class>

    <Class name="GroupResult" namespace="System.Linq.Dynamic">
      <Description>The result of a call to `DynamicQueryable.GroupByMany()`.</Description>
      <Properties>
        <Property name="Key" valueType="object" frameworks="Net35" accessors="Get">
          <Description>The key value of the group.</Description>
        </Property>
        <Property name="Key" valueType="dynamic" frameworks="Net40Plus" accessors="Get">
          <Description>The key value of the group.</Description>
        </Property>
        <Property name="Count" valueType="int" accessors="Get">
          <Description>The number of resulting elements in the group.</Description>
        </Property>
        <Property name="Items" valueType="int" accessors="Get">
          <Description>The resulting elements in the group.</Description>
        </Property>
        <Property name="Subgroups" valueType="int" accessors="Get">
          <Description>The resulting subgroups in the group.</Description>
        </Property>
      </Properties>
      <Methods>
        <Method name="ToString" returnType="string">
          <Description>Returns a string showing the key of the group and the number of items in the group.</Description>
        </Method>
      </Methods>
    </Class>

    <Class name="DynamicLinqTypeAttribute" namespace="System.Linq.Dynamic">
      <Description>Indicates to Dynamic Linq to consider the Type as a valid dynamic linq type. Use only when `GlobalConfig.CustomTypeProvider` is set to `DefaultDynamicLinqCustomTypeProvider`.</Description>
    </Class>

    <Class name="DefaultDynamicLinqCustomTypeProvider" namespace="System.Linq.Dynamic">
      <Description>The default `IDynamicLinkCustomTypeProvider`. Scans the current `AppDomain` for all types marked with `DynamicLinqTypeAttribute`, and adds them as custom Dynamic Link types.</Description>
      <Methods>
        <Method name="GetCustomTypes" returnType="HashSet&lt;Type&gt;">
          <Description>Returns a list of custom types that Dynamic Linq will understand.</Description>
        </Method>
      </Methods>
    </Class>

    <Class name="IDynamicLinkCustomTypeProvider" namespace="System.Linq.Dynamic" isInterface="true">
      <Description>Interface for providing custom types for Dynamic Linq.</Description>
      <Methods>
        <Method name="GetCustomTypes" returnType="HashSet&lt;Type&gt;">
          <Description>Returns a list of custom types that Dynamic Linq will understand.</Description>
        </Method>
      </Methods>
    </Class>

    <Class name="GlobalConfig" namespace="System.Linq.Dynamic">
      <Description>Static configuration class for Dynamic Linq.</Description>
      <Remarks>`GlobalConfig` is a static class for setting `AppDomain` level settings for the *Dynamic Linq Library*.</Remarks>
      <Properties>
        <Property name="CustomTypeProvider" valueType="IDynamicLinqCustomTypeProvider" accessors="GetSet" isStatic="true">
          <Description>Gets or sets the `IDynamicLinkCustomTypeProvider`.</Description>
          <ValueTypeDescription>A value that determines how custom types for Dynamic Linq are provided. The default value is set to `DefaultDynamicLinqCustomTypeProvider`.</ValueTypeDescription>
        </Property>
      </Properties>
    </Class>
    
  </Classes>
  
  <Expressions>
    <Expression name="Sum">
      <Description>Computes the sum of a sequence of values.</Description>
      <Examples>
        <Example>
          <HeaderRemarks>The following is an example of a `Sum` expression.</HeaderRemarks>
          <ExampleCode>int[] initValues = new int[] { 1, 2, 3, 4, 5 };&#xA;var qry = initValues&#xA;    .AsQueryable()&#xA;    .Select(x => new { strValue = "str", intValue = x })&#xA;    .GroupBy(x => x.strValue);&#xA;&#xA;var result = qry.Select("Sum(intValue)");</ExampleCode>
          <EquivalentCode>int[] initValues = new int[] { 1, 2, 3, 4, 5 };&#xA;var qry = initValues&#xA;    .AsQueryable()&#xA;    .Select(x => new { strValue = "str", intValue = x })&#xA;    .GroupBy(x => x.strValue);&#xA;&#xA;var result = qry.Sum(x => x.intValue);</EquivalentCode>
        </Example>
      </Examples>
    </Expression>

    <Expression name="Contains">
      <Description>Determines whether a sequence contains a specified element.</Description>
      <Remarks>Compare to [**In** Expression][0].
      
 [0]: /Expressions/In</Remarks>
      <Examples>
        <Example>
          <HeaderRemarks>The following code example demonstrates how to use the `Contains` expression to determine whether a sequence contains a specific element.</HeaderRemarks>
          <ExampleCode>var testQuery = baseQuery.Where("@0.Contains(UserName)", containsList).Select("Id");</ExampleCode>
        </Example>
      </Examples>
    </Expression>

    <Expression name="In">
      <Description>Determines whether a sequence contains a specified element.</Description>
      <Remarks>
        Compare to [**Contains** Expression][0].

 [0]: /Expressions/Contains
      </Remarks>
      <Examples>
        <Example>
          <HeaderRemarks>The following code example demonstrates how to use the `In` expression to determine whether a sequence contains a specific element.</HeaderRemarks>
          <ExampleCode>var rangeOfNumbers = Enumerable.Range(1, 100).ToArray();

//Use a fixed set of numbers to test for
var result1 = rangeOfNumbers.AsQueryable().Where("it in (2,4,6,8)").ToArray();

//Use a variable set of numbers to test for
var values = new int[] { 2, 4, 6, 8 };
var result2 = rangeOfNumbers.AsQueryable().Where("it in @0", testInExpression).ToArray();</ExampleCode>
        </Example>
      </Examples>
    </Expression>

    <Expression name="First">
      <Description>Returns the first element of a sequence.</Description>
    </Expression>

    <Expression name="FirstOrDefault">
      <Description>Returns the first element of a sequence, or a default value if the sequence contains no elements.</Description>
    </Expression>

    <Expression name="Single">
      <Description>Returns the only element of a sequence, and throws an exception if there is not exactly one element in the sequence.</Description>
    </Expression>

    <Expression name="SingleOrDefault">
      <Description>Returns the only element of a sequence, or a default value if the sequence is empty; this method throws an exception if there is more than one element in the sequence.</Description>
    </Expression>

    <Expression name="Select">
      <Description>Projects each element of a sequence into a new form.</Description>
    </Expression>

    <Expression name="Where">
      <Description>Filters a sequence of values based on a predicate.</Description>
    </Expression>

    <Expression name="OrderBy">
      <Description>Sorts the elements of a sequence in ascending order according to a key.</Description>
    </Expression>

    <Expression name="OrderByDecending">
      <Description>Sorts the elements of a sequence in decending order according to a key.</Description>
    </Expression>

  </Expressions>
  
</DynLINQDoc>